#线程：在一个程序里的一个执行路线就叫做线程（thread）
      线程是一个进程内部的控制序列
      一个进程至少有一个线程

进程是系统资源分配的最小单位
线程是程序执行的最小单位
线程共享进程数据，但也自己的栈空间
每个进程都有独立的4GB 的独立地址空间（32位）

#fork  /  pthread_create 区别
fork: 复制一个新进程，并且拥有一个独立进程空间，新进程有自己的
      变量和他自己的PID，运行时间也是独立的，他在执行时候几乎和
      创建他的进程独立

pthread_create：创建一个新线程的时候，心得执行线程会拥有自己的
堆栈（因此也就有自己的局部变量），但要与他的创建者共享全局变量，
文件描述符，信号处理器和当前工作目录状态。

#线程 进程的区别
创建一个线程的的代价要比创建一个进程小的多
切换， 线程需要操作系统做的事情与进程比较要少的多

能充分利用多处理器的可并行数量(双核处理器)
1 个程序 单线程，最多竞争一个CPU
1个程序  2线程，可以竞争到多个处理器
单线程的缺点，遇到阻塞的。CPU就不能执行其他的进程

多线程其实就是提高性能，充分利用多处理器，将程序分配到不同的线程中执行，期间需要
用到线程同步去完成任务。

pid_t        thread_t
fork         pthread_create()
waitpid      pthread_join()
exit         pthread_exit
zombie       zombie  //(可以通过属性设置为)
             pthread_detach 
kill         pthread_cancel //避免僵尸线程

线程结束：
自杀pthread_exit;
他杀pthread_cancel;


#线程缺点
1. 一个很少被外界阻塞的计算型线程，性能损失，同步开销增加
2. 健壮性差，线程共享进程资源
3. 缺乏访问控制  线程中调用OS函数对整个进程造成影响
4. 编写与调试难度增加


#线程没有父子线程之称，可以主线程（初始化的线程），和新线程

#线程调度 取决于系统是如何调度的  usleep()   ,微秒

#主线程结束了，新线程可能还没有结束呢，  // pthread_join()





